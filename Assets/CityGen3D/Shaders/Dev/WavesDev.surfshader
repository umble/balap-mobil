// CityGen3D water shader tessellated Gerstner waves
BEGIN_OPTIONS
   ShaderName "CityGen3D/WavesDev"
   Stackable "False"
   Queue "Transparent"
   Alpha "Blend"
   Tessellation "Edge"
END_OPTIONS

BEGIN_PASS("All")
    Cull Off // double sided
END_PASS

BEGIN_PROPERTIES
	_Color ("Color", Color) = (0, 0.25, 0.25, 0.5)
	_Smoothness("Smoothness", Range(0,1)) = 0.9
    _WaveSpeed("Wave Speed", Range(0.1,10)) = 4
	_TessEdgeLength("Edge Length", Range(1, 128)) = 8 // tessellation edge factor
    _WaveA ("Wave A", Vector) = (0.9, 1, 0.25, 3) // wave properties: x/y = direction, z = steepness, w = wavelength
    _WaveB ("Wave B", Vector) = (1, 0.6, 0.25, 1.5)
    _WaveC ("Wave C", Vector) = (1.2, 1.3, 0.25, 0.75)
END_PROPERTIES


BEGIN_CBUFFER
	half4 _Color;
    half _Smoothness;
	float _WaveSpeed;
	float _TessEdgeLength;
	float4 _WaveA;
	float4 _WaveB;
	float4 _WaveC;   
END_CBUFFER

BEGIN_CODE

    float3 GetTessFactors ()
    {
       return float3(_TessEdgeLength, 0, 0);
    }
		
    float3 GerstnerWave( float4 wave, float3 p, inout float3 tangent, inout float3 binormal )
	{
		float steepness = wave.z;
		float wavelength = wave.w;
		float k = 2 * 3.14159265359f / wavelength;
		float c = sqrt(9.8 / k);
		float2 d = normalize(wave.xy);
		float f = k * (dot(d, p.xz) - c * _Time.x * _WaveSpeed);
		float a = steepness / k;

		tangent += float3(
			-d.x * d.x * (steepness * sin(f)),
			d.x * (steepness * cos(f)),
			-d.x * d.y * (steepness * sin(f))
		);
		binormal += float3(
			-d.x * d.y * (steepness * sin(f)),
			d.y * (steepness * cos(f)),
			-d.y * d.y * (steepness * sin(f))
		);
		return float3(
			d.x * (a * cos(f)),
			a * sin(f),
			d.y * (a * cos(f))
		);
	}

	void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
    {  
		float3 gridPoint = v.vertex.xyz;
		float3 tangent = float3(1, 0, 0);
		float3 binormal = float3(0, 0, 1);
		float3 p = gridPoint;
		p += GerstnerWave(_WaveA, gridPoint, tangent, binormal);
		p += GerstnerWave(_WaveB, gridPoint, tangent, binormal);
		p += GerstnerWave(_WaveC, gridPoint, tangent, binormal);
		float3 normal = normalize(cross(binormal, tangent));
		v.vertex.xyz = p;
		v.normal = normal;
    }
	
	void SurfaceFunction(inout Surface o, ShaderData d)
	{
      o.Albedo = _Color.rgb;
      o.Alpha = _Color.a;
      o.Smoothness = _Smoothness;
	}

END_CODE

